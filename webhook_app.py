# webhook_app.py import os import logging from fastapi import FastAPI, Request, HTTPException from aiogram.types import Update from main import bot, dp, BOT_TOKEN app = FastAPI(title="Telegram Bot on Render") WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET") or BOT_TOKEN # idéalement définir WEBHOOK_SECRET dans Render # ---- Health / keep-alive ---- @app.get("/") async def root_get(): return {"ok": True, "service": "telegram-bot"} @app.head("/") async def root_head(): # Certains health checks (Render/proxy) envoient HEAD / return "" @app.get("/ping") async def ping_get(): return {"status": "ok"} @app.head("/ping") async def ping_head(): return "" @app.options("/ping") async def ping_options(): # Si un proxy envoie OPTIONS, on renvoie 200 return "" # ---- Webhook Telegram ---- @app.post(f"/webhook/{WEBHOOK_SECRET}") async def telegram_webhook(request: Request): try: payload = await request.json() except Exception: raise HTTPException(status_code=400, detail="Bad JSON") try: update = Update.model_validate(payload) # aiogram v3 / pydantic v2 await dp.feed_update(bot, update) except Exception as e: logging.exception("Erreur pendant le traitement du webhook: %s", e) # On évite les retries agressifs côté Telegram return {"ok": False, "error": "internal"} return {"ok": True}
